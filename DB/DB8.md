# 8일차

## Database 8일차

- WINDOW FUNCTION 개요

  ```
  기존 관계형 데이터베이스는 칼럼과 칼럼 간의 연산, 비교, 연결, 집합에 대한 집계는 쉬운 반면

  행과 행 간의 관계를 정의하거나, 행과 행 간을 비교하는 것을 하나의 SQL 문으로 처리하는 것은 매우 어려운 문제였음

  PL/SQL, PRO*C 같은 절차형 프로그램을 작성하거나,
  INLINE VIEW를 이용해 복잡한 SQL 문을 작성해야 하던 것을 부분적이나마
  행과 행 간의 관계를 쉽게 정의하기 위해 만든 함수임
  ```

  > 윈도우 함수를 활용하면 복잡한 프로그램을 하나의 SQL 문장으로 쉽게 해결 가능

<br />

- 표현식

  - WINDOW 함수에서는 OVER 문구가 키워드로 필수 포함

  ```
  SELECT WINDOW_FUNCTION (ARGUMENTS) OVER
  ([PARTITION BY 칼럼] [OVER BY 절] [WINDOWING 절])
  FROM 테이블명;
  ```

<br />

- WINDOW FUNCTION

  - 기존에 사용하던 함수도 있고, 새롭게 WINDOW 함수용으로 추가된 함수도 있음

  - ARGUMENTS(인수): 함수에 따라 0-N 개의 인수 지정 가능

  - PARTITION BY 절: 전체 집합을 기준에 의해 소그룹으로 나눔

  - ORDER BY 절: 어떤 항목에 대해 순위를 지정할지 기술

  - WINDOWING 절: 함수의 대상이 되는 행 기준의 범위를 강력하게 지정

    - ROWS: 물리적인 결과 행의 수

    - RANGE: 논리적인 값에 의한 범위

    > 둘 중 하나를 선택해서 사용 가능

  > WINDOWING 절은 SQL SERVER에서는 지원하지 않음

<br />

- 윈도우 함수 간단 예제

  - ROW_NUMBER()

  ```sql
  SELECT JOB, ENAME, SAL,
    RANK() OVER (ORDER BY SAL DESC) RANK_NUM,
    ROW_NUMBER() OVER (ORDER BY SAL DESC) ROW_NUMBER
  FROM EMP;


  SELECT DEPTNO, ENAME, SAL,
      ROW_NUMBER() OVER (PARTITION BY DEPTNO ORDER BY SAL DESC) ROW_NUMBER
  FROM EMP;


  SELECT ENAME,
      CASE WHEN TO_CHAR(HIREDATE, 'MM') = '01' THEN SAL ELSE 0 END AS M1,
      CASE WHEN TO_CHAR(HIREDATE, 'MM') = '02' THEN SAL ELSE 0 END AS M2,
      CASE WHEN TO_CHAR(HIREDATE, 'MM') = '03' THEN SAL ELSE 0 END AS M3,
      CASE WHEN TO_CHAR(HIREDATE, 'MM') = '04' THEN SAL ELSE 0 END AS M4,
      CASE WHEN TO_CHAR(HIREDATE, 'MM') = '05' THEN SAL ELSE 0 END AS M5,
      CASE WHEN TO_CHAR(HIREDATE, 'MM') = '06' THEN SAL ELSE 0 END AS M6,
      CASE WHEN TO_CHAR(HIREDATE, 'MM') = '07' THEN SAL ELSE 0 END AS M7,
      CASE WHEN TO_CHAR(HIREDATE, 'MM') = '08' THEN SAL ELSE 0 END AS M8,
      CASE WHEN TO_CHAR(HIREDATE, 'MM') = '09' THEN SAL ELSE 0 END AS M9,
      CASE WHEN TO_CHAR(HIREDATE, 'MM') = '10' THEN SAL ELSE 0 END AS M10,
      CASE WHEN TO_CHAR(HIREDATE, 'MM') = '11' THEN SAL ELSE 0 END AS M11,
      CASE WHEN TO_CHAR(HIREDATE, 'MM') = '12' THEN SAL ELSE 0 END AS M12
  FROM EMP;
  ```

<br />

- PIVOT()

  ```sql
  SELECT *
  FROM (SELECT ENAME, SAL, TO_CHAR(HIREDATE, 'MM') AS MONTH
          FROM EMP)
  PIVOT (
      SUM(SAL)
      FOR MONTH IN('01' AS M1, '02' AS M2, '03' AS M3,
          '04' AS M4, '05' AS M5, '06' AS M6,
          '07' AS M7, '08' AS M8, '09' AS M9,
          '10' AS M10, '11' AS M11, '12' AS M12
      )
  );

  SELECT ENAME, SAL, TO_CHAR(HIREDATE, 'MM') AS MONTH
  FROM EMP;
  ```

<br />

### DDL

- 데이터 모델의 이해

  - 모델링의 정의

    ```
    사람이 살아가면서 나타날 수 있는 다양한 현상은 사람, 사물, 개념 등에 의해 발생된다고 할 수 있으며

    모델링은 이것을 표기법에 의해 규칙을 가지고 표기하는 것 자체를 의미

    => 모델을 만들어가는 일 자체를 모델링으로 정의

    ```

    ```
    현실 세계 -----------------------> 모델
              추상화, 단순화, 명확화
    (복잡한 현실 세계를 일정한 표기법에 의해 표현하는 일)
    ```

    > 모델링의 정의 중 하나: 모델이란 복잡한 현실 세계를 단순화시켜 표현하는 것

<br />

- 모델링의 특징

  ```
  1. 추상화: 현실 세계를 일정한 형식에 맞춰 표현한다는 의미
           => 다양한 현상을 일정한 양식인 표기법에 의해 표현한다는 것

  2. 단순화: 복잡한 현실 세계를 약속된 규약에 의해 제한된 표기법이나 언어로 표현하여 쉽게 이해할 수 있도록 하는 개념

  3. 명확화: 누구나 이해하기 쉽게 하기 위해 대상에 대한 애매모호함을 제거하고 정확하게 현상을 기술하는 것
  ```

<br />

- 모델링의 세 가지 관점

  - 데이터 관점(data, what), 프로세스 관점(process, how), 데이터와 프로세스의 상관 관점(data vs process)

  > 참고: 데이터 관점에서 먼저 이해하도록 진행

<br />

- 데이터 모델의 기본 개념

  - 데이터 모델링: 정보시스템을 구축하기 위해, 해당 업무에 어떤 데이터가 존재하는지 또는 업무가 필요로 하는 정보는 무엇인지를 분석하는 방법

<br />

- 데이터 모델 장점

  1. 시스템을 현재 또는 원하는 모습이 무엇인지 가시화하도록 도움

  2. 시스템의 구조와 행동을 명세화(문서)할 수 있음

  3. 시스템을 구축하는 과정에서 결정한 것을 확인 가능(증명 가능)

<br />

- 데이터 모델링 유의점

  1. 중복: 같은 데이터를 사용하는 무언가(사람, 시간, 장소) 파악에 도움 => 지식 응용은 데이터베이스가 같은 정보를 저장하는 잘못을 하지 않도록 해야 함

  2. 비 유연성: 어떻게 설계했느냐에 따라 사소한 업무 변화에도 데이터 모델이 수시로 변경된다면 유지보수의 어려움을 가중 시킬 수 있음

  3. 비일관성: 데이터의 중복이 없더라도 비일관성은 발생, 개발자가 다른 데이터와 모순된다는 고려 없이 일련의 데이터를 수정할 수 있다면 위험

<br />

```
현실 세계           개념적 데이터 모델링          개념 세계
개체          ---------------------->       개념적 구조
ㅗㅜ               물리 세계(컴퓨터)               ㅜ        논리적 데이터 모델링
ㅗㅜ                                           ㅜ
데이터베이스    <----------------------       논리적 구조
                  물리적 데이터 모델링
        (현실과 데이터베이스 사이의 모델)
```

- 개념 - 논리 - 물리 데이터 모델

  | 데이터 모델링        | 내용                                                                                       | 수준   |
  | -------------------- | ------------------------------------------------------------------------------------------ | ------ |
  | 개념적 데이터 모델링 | 추상화 수준이 높고 업무 중심적이고 포괄적인 수준의 모델링 진행                             | 추상적 |
  | 논리적 데이터 모델링 | 시스템으로 구축하고자 하는 업무에 대해 key, 속성, 관계 등을 정확하게 표현(재사용성이 높음) |
  | 물리적 데이터 모델링 | 실제로 데이터베이스에 이식할 수 있도록 성능, 저장 등 물리적인 성격을 고려하여 설계         | 구체적 |

<br />

- 프로젝트 생명주기(Life Cycle)

  ```
  분석 -> 설계 -> 개발 -> 테스트 -> 전환 / 이행(DB) -> 정보시스템 구축
  ```

<br />

- 데이터 독립성 요소

  - 외부 스키마(External Schema)

  - 개념 스키마(Conceptual Schema)

  - 내부 스키마(Internal Schema)

  ```
  -  DB에서의 외/내부

    - 외부: 응용 프로그램

    - 내부: DB, 데이터 저장 공간
  ```

<br />

- 사상(Mapping)

  - 상호 독립적인 개념을 연결 시켜주는 다리를 뜻함

  - 데이터 독립성에는 크게 2가지의 사상이 도출됨

    1. 외부/개념적 사상: 외부적 뷰와 개념적 뷰의 상호 관련성을 정의함(문서)

    2. 개념적/내부적 사상: 개념적 뷰와 저장된 데이터베이스의 상호관련성을 정의함(문서)

  - ex)

    ```
    1. 사용자가 접근하는 형식에 따라 다른 타입의 필드를 가질 수 있음
        개념적 뷰의 필드 타입은 변화가 없음

    2. 만약 저장된 데이터베이스 구조가 바뀐다면 개념적/내부적 사상이 바뀌어야 함
        => 개념적 스키마가 그대로 남아있게 됨
    ```

  > 데이터 독립성을 보장하기 위해서 DBA가 필요할 때마다 변경해 주어야 함

<br />

- 데이터 모델링의 중요한 세 가지 개념

  1. 업무가 관여하는 어떤 것(Things)

  2. 어떤 것이 가지는 성격(Attribute)

  3. 업무가 관여하는 어떤 것 간의 관계(Relationships)

  ```
  사물이나 사건 등을 바라볼 때 전체를 지칭하는 용어 -> 어떤 것

  그 어떤 것이 가지는 세부적인 사항 -> 성격

  각각의 어떤 것은 다른 어떤 것과 연관성을 가질 수 있음 -> 관계
  ```

  - ex)

    ```
    A와 B가 존재하고 둘 사이는 서로 사랑하는 연인 사이임
    A는 키가 180cm에 성격은 친절하고,
    B는 키가 165cm에 세심하며 활달한 성격을 가짐


    - Things: A, B

    - Attribute: 180cm에 친절
                 165cm에 세심하며 활달한

    - Relationships: 서로 사랑하는 연인사이
    ```

<br />

- 용어의 구분 정의

  - 어떤 것: Entity(엔티티) === 테이블(Table)

  - 어떤 것 간의 연관: Relationship(관계) === JOIN, 제약조건

  - 어떤 것의 성격: Attribute(속성) === 칼럼(Column)

<br />

- 데이터 모델링의 이해관계자

  - 실제 업무 시스템을 사용하는 자 = 사용자

  - 업무 시스템을 개발하는 자 = 개발자

  > 개발자가 데이터 모델링도 같이 하게 되는 경우 많음

  ```
  -  데이터 모델링 과정

  1. 단지 DB를 설계한다는 측면보다는 업무를 이해하고 분석하여 표현하는 것이 중요

  2. 표현된 내용을 바탕으로 프로젝트 관련자와 의사소통하고 프로그램이나 다른 표기법과 비교 검증하는 일을 수행하는 등,
     많은 시간을 업무 분석과 설계에 할애하기 때문에 업무 영역별 개발팀에서 보통 데이터 모델링을 진행하게 됨

  // 대부분의 개발하는 사람들은 데이터 모델에 많은 관심을 가지지 않고
  // 단지 프로그램을 개발하기 위한 프로그래밍 언어에만 많은 관심을 두고 애플리케이션을 개발하는 데에
  // 많은 시간을 투자하는 경우가 많음
  ```

- 데이터 모델(설계, 회의 시 만날 수 있는 사람)

  - DBA, 프로젝트 개발자(SYSTEM ENGINEER), 전문 모델러, 현업업무전문가(IT 조금 이해하는 수준)

<br />

- 데이터 모델 표기법

  - ERD(Entity Relationship Diagram)

    - 각 업무 분석에서 도출된 엔티티와 엔티티 간의 관계를 이해하기 쉽게 도식화된 다이어그램으로 표시하는 방법(E-R MOdel)

    - 엔티티 배치 방향: 일반적으로 "좌 -> 우, 상 -> 하"로 구성

<br />

- ERD 작업 순서

  ```
  엔티티 그림 -> 엔티티 적절하게 배치 -> 엔티티 간의 관계 설정 ->

  관계명 기술 -> 관계의 참여도 기술 -> 관계의 필수 여부 기술
  ```

  > 참고: https://jie0025.tistory.com/112

<br />

- 앤티티(Entity) = 테이블(Table)

  - 개념: 실체, 객체라고 번역되기도 하지만 실무적으로 엔티티라는 외래어 많이 사용

  - 정의

    - 분별할 수 있는 사물

    - DB 내에서 분별 가능한 객체

    - 정보를 저장할 수 있는 어떤 것

    - 정보가 될 수 있는 사람, 장소, 사건, 개념 등

  ```
  - 정의 공통점

    1. 사람, 장소, 물건, 사건, 개념 등의 명사에 해당

    2. 업무상 관리가 필요한 관심사에 해당

    3. 저장이 되기 위한 어떤 것
  ```

  > 엔티티: 업무에 필요하고 유용한 정보를 저장 및 관리하기 위한 집합적인 것

  <br />

  - 종류 예시: 과목, 강사, 사건

<br />

- 엔티티와 인스턴스에 대한 내용과 표기법

  ```
  - 엔티티는 집합에 속하는 개체들의 특성을 설명할 수 있는 속성(Attribute)을 가짐

  ex) 학생이라는 엔티티는 학번, 이름, 이수학점, 생일, 주소 등의 속성으로 특징지을 수 있음

  => 여러 속성 가운데 엔티티 인스턴스 전체가 공유할 수 있는 공통 속성도 있고,
     일부에만 해당하는 개별 속성도 있을 수 있음

  => 엔티티: 인스턴스의 집합
  ```

<br />

- 엔티티의 특징

  > 도출된 엔티티가 아래의 성질 불만족 시 적절치 않은 엔티티일 확률 상승

  1. 반드시 해당 업무에서 필요하고 관리하고자 하는 정보여야 함

  2. 유일한 식별자에 의해 식별할 수 있어야 함

  3. 영속적으로 존재하는 인스턴스의 집합이어야 함(칼럼 두 개 이상)

  4. 업무 프로세스에 의해 이용되어야 함

  5. 반드시 속설 필요

  6. 다른 엔티티와 최소한 한 개 이상의 관계가 있어야 함(특별한 상황에서는 관계가 없어도 됨)

  ```
  가. 업무에서 필요로 하는 정보
  나. 식별할 수 있어야 함: 모두 다 동일한 이름(동명이인), 속성 관계?
  다. 인스턴스의 집합: 두 개 이상
  라. 업무 프로세스의 의해 이용
  마. 속성 포함
  바. 관계의 존재
  ```

<br />

- 엔티티의 명명

  - 엔티티를 명명하는 일반적인 기준

  1. 가능하면 현업 업무에서 사용하는 용어

  2. 가능하면 약어 사용 X

  3. 단수 명사 사용

  4. 모든 엔티티에서 유일하게 이름이 부여되어야 함 => 고유한 테이블 명

  5. 엔티티 생성 의미대로 이름 부여

<br />

- 속성

  - 속성(Attribute) 개념

    - 사전적 의미: 사물의 성질, 특징 또는 본질적인 성질이 없다면 실체를 생각할 수 없는 것

      > 본질적인 속성: 어떤 사물 또는 개념에 없어서는 안 될 징표의 전부

    <br />

    - 데이터 모델링 관점에서의 속성 정의

    ```
    업무에서 필요로 하는, 인스턴스로 관리하고자 하는, 의미상 더 이상 분리되지 않는, 최소의 데이터 단위

    => 업무상 관리하기 위한 최소의 의미 단위로 생각할 수 있고,
       이것은 엔티티에서 한 부분을 담당하고 있음
    ```

<br />

- 예시

  - 강사 엔티티

    - 속성: 이름, 주소, 생년월일, 계약일자, 전문분야, 경력 등

<br />

- 속성의 정의

  - 업무에서 필요로 함

  - 의미상 더 이상 분리되지 않음

  - 엔티티를 설명하고 인스턴스의 구성요소가 됨

<br />

- 엔티티, 인스턴스 속성, 속성값에 대한 내용과 표기법

  - 엔티티, 인스턴스, 속성, 속성값에 대한 관계

    ```
    - 한 개의 엔티티는 두 개 이상의 인스턴스의 집합이어야 함

    - 한 개의 엔티티는 두 개 이상의 속성을 가짐

    - 한 개의 속성은 한 개의 속성값을 가짐
    ```

<br />

- 속성 표기법

  - 엔티티 내에 이름을 포함하여 표현

<br />

- 속성의 특징

  > 속성이 아래의 특징을 만족하지 못할 경우 적절치 않은 속성일 확률이 높음

  1. 해당 업무에서 필요하고 관리하고자 하는 정보

  2. 정규화 이론에 근간하여 정해진 주 식별자에 함수적 종속성을 가져야 함

  3. 하나의 속성에는 한 개의 값만을 가짐

     > 하나의 속성에 여러 개의 값이 있는 다중값일 경우 별도의 엔티티 이용해 분리

<br />

- 속성의 분류

  1. 기본 속성: 업무로부터 추출한 모든 속성, 가장 일반적이고 많은 속성을 차지함

     - 코드상 데이터, 엔티티를 식별하기 위해 부여된 일련번호, 다른 속성을 계산하거나 영향을 받아 생성된 속성을 제외한 모든 속성은 기본 속성

  2. 설계 속성: 업무상 필요한 데이터 이외에 데이터 모델링을 위해, 업무를 규칙화하기 위해 속성을 새로 만들거나 변형하여 정의하는 속성

     - 일련번호와 같은 속성은 모델상에서 새로 정의하는 설계 속성에 해당

  3. 파생 속성: 다른 속성에 영향을 받아 발생하는 속성으로써 보통 계산된 값들이 이에 해당

     - 다른 속성에 영향을 받기 때문에 프로세스 설계 시 데이터 정합성을 유지하기 위해 유의해야 할 점이 많으며 가급적 파생 속성을 적게 정의하는 것이 좋음

  <br />

  - 예시

  ```
  - 기본 속성: 제품이름, 제조년월, 제조원가

  - 설계 속성(1:1 치환): 001-식품용기, 002-약품용기, 003-기타용기

  - 파생 속성: 계산값, 전체 약품 용기 총금액
  ```

<br />

- 도메인(Domain)

  - 속성의 도메인: 각 속성은 가질 수 있는 값의 범위

  - 엔티티 내에서 속성에 대한 데이터 타입과 크기, 제약사항을 지정하는 것

  - 예시

    ```
    학생이라는 엔티티가 있을 때 학점이라는 속성의 도메인은 0.0에서 4.5 사이의 실수값이며 주소라는 속성은 길이가 20자리 이내인 문자열로 정의할 수 있음
    ```

<br />

- 속성의 명명규칙(Naming)

  - 속성명이 곧 사용자 인터페이스(User Interface)에 나타나기 때문에 업무와 직결되는 항목이어야 함

  - 속성 이름을 정확하게 부여하고 용어의 혼란을 없애기 위해서 용어 사전이라는 업무 사전을 프로젝트에 사용하게 됨

  - 각 속성이 갖는 값의 종류와 범위를 명확하게 하기 위해 도메인 정의를 미리 하여 용어 사전과 같이 사용

  ```
  1. 해당 업무에서 사용하는 이름 부여

  2. 서술식 속성명은 사용하지 않음

  3. 약어 사용은 가급적 제한

  4. 전체 데이터 모델에서 유일성 확보를 하는 것이 좋음


  > 해당 업무에서 사용되지 않는 속성 명칭은 사용하지 않는 것이 좋음

  > 수식어가 많으면 의미 파악이 힘들고, 명확한 의미 파악이 어려움 => 소유격도 사용 X
  ```

  > 가능하면 모든 속성의 이름은 유일하게 작성 <br />
  > => 반정규화 사용 시 속성명의 충돌(Conflict)을 해결하여 안정적으로 반정규화 적용 가능

<br />

- 관계

  - 관계(Relationship)의 개념

    - 사전적 정의: 상호 연관성이 있는 상태

    - 데이터 모델링의 정의: 엔티티의 인스턴스 사이의 논리적인 연관성으로서 존재의 형태로서나 행위로써 서로에게 연관성이 부여된 상태

    > 관계는 엔티티와 엔티티 간 연관성을 표현하기 때문에 엔티티의 정의에 따라 <br /> 영향을 받기도 하고, 속성 정의 및 관계 정의에 따라서도 다양하게 변할 수 있음

  <br />

  ```
  강사 -------- 가르친다 -------- 수강생
  인스턴스 사이의 논리적인 연관성으로서
  존재 또는 행위로써 서로에게 연관성이 부여된 상태

  인스턴스 각각은 자신의 연관성을 갖고 있을 수 있음
  이것은 집합하여 강의라는 관계 도출

  - A 강사는 B 수강생을 가르침
  - C 강사는 D 수강생에게 강의함
  - A 강사는 D 수강생에게 강의함
  ```

<br />

- 관계의 분류

  - 관계가 존재에 의한 관계와 행위에 의한 관계로 구분될 수 있는 것은 관계 연결에 있어 어떤 목적으로 연결되었느냐에 따라 분류하기 때문임

  ```
  - 존재에 의한 관계: 사원은 부서에 항상 속해있음

  - 행위에 의한 관계: 주문은 고객이 주문할 때 발생 됨, 고객은 햄버거를 주문
  ```

<br />

- 관계의 표기법

  - 관계명(Membership): 관계의 이름

  - 관계 차수(Cardinality): 1:1, 1:M, M:N

  - 관계 선택사양(Optionality): 필수 관계, 선택 관계

<br />

- 관계명(Membership)

  - 엔티티가 관계에 참여하는 형태를 지칭

  - 관계 이름은 능동적이거나 수동적으로 명명됨

  1. 애매한 동사를 피함: 관계된다, 관련이 있다, 이다, 한다 X

     > 위의 동사는 구체적이지 않아 어떤 행위가 있는지, 두 참여자 간 어떤 상태가 존재하는지 파악할 수 없음

  2. 현재형으로 표현: 수강을 신청했다, 강의 할 것이다 X

  ```
  관계의 관계명
    포함한다
  부서 ----------------- 사원
                    소속됨
  ```

<br />

- 관계 차수(Cardinality)

  - 두 개의 엔티티 간 관계에서 참여자의 수를 표현하는 것

  - 가장 중요하게 고려해야 할 사항은 한 개의 관계가 존재하느냐 아니면 두 개 이상의 멤버십이 존재하느냐를 파악하는 것

  > 참고: https://jie0025.tistory,com/112 (IE표기법)

  ```
  1:1 (one to one)

  1:M (one to many)

  M:M (many to many)
  ```

<br />

- 관계 선택사양(Optionality)

  - 필수 참여 관계: 참여하는 모든 참여자가 반드시 관계가 있는, 타 엔터티의 참여자와 연결이 되어야 하는 관계

  ```
  지하철 문이 닫히지 않았는데 지하철이 떠난다면 발생할 일은?

  => 반드시 지하철 문이 닫혀야만 지하철은 출발함
  => 이때 지하철 출발과 지하철 문 닫힘은 필수적으로 연결 관계가 있는 것
  => 데이터 모델의 관계에서의 필수 참여 관계
  ```

  <br />

  - 선택 참여 관계: 물리 속성에서 Foreign Key로 연결될 경우 Null을 허용할 수 있음

<br />

- 관계의 정의 및 읽는 방법

  - 데이터 모델을 읽는 방법은 먼저 관계에 참여하는 기준 엔티티를 하나 또는 각(Each)으로 읽고 대상 엔티티의 개수(하나, 하나 이상)를 읽고 관계 선택사양과 관계명을 읽도록 함

  ```
  - 기준 엔티티를 한 개(one) 또는 각(Each)으로 읽음

  - 대상 엔티티의 관계 참여도 즉 개수(하나, 하나 이상)를 읽음

  - 관계 선택사양과 관계명을 읽음
  ```
